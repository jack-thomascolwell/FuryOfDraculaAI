(in-microtheory FuryOfDraculaAgentPlansMt)
(genlMt Session-ReasonerPlanMt FuryOfDraculaAgentPlansMt)



;;; playDracula plan

(preconditionForMethod
  (and

      (ist-Information ?gamestate (location Dracula ?currentLocation))


  )
  (methodForAction
    (playDracula ?gamestate)
    (actionSequence
      (TheList

      ;;; construct roundMt for initial evaluateAdjLocations call
      (doRecord (ist-Information (adjLocationsRoundMtFn 0) (currentLocation ?currentLocation)))
      (doRecord (ist-Information (adjLocationsRoundMtFn 0) (added (TheSet))))
        ;;; call stressLevel on current gameState
      ;;; FIXME commented out for testing purposes
      ;;;(doAgentPlan (stressLevel ?gamestate))
      ;;; evaluate potential moves
      (doAgentPlan (evaluateAdjLocations ?gamestate 0))

      )
    )
  )
)

;;; record card plan
(preconditionForMethod
  (and
    (ist-Information ?gamestate (location Dracula ?currentLocation))
    (ist-Information ?gamestate (stressAt ?stressLevel ?currentLocation))
    (leaveCard ?stressLevel ?card)
  )
  (methodForAction
    (recordEncounterCard ?gamestate)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gamestate) (leaveEncounter ?card)))
      )
    )
  )
)


;;; FIXME this never happens!!! we go straight to base case!!!
;;; evaluateAdjLocations recursive case 1
(preconditionForMethod
	(and
		;;; extract info from roundMt
		(ist-Information (adjLocationsRoundMtFn ?round) (currentLocation ?currentLocation))
		(ist-Information (adjLocationsRoundMtFn ?round) (added ?added))


		;;; find adjacent location that's connected by road or port.
		(connectedTo ?currentLocation ?nextLocation ?way)
		(elementOf ?way (TheSet road port))

		;;;nextLocation not on trail
    (evaluate ?trailSet (TheClosedRetrievalSetOf ?loc (ist-Information ?gamestate (locationOnTrail ?loc ?space))))
		(uninferredSentence (elementOf ?nextLocation ?trailSet))


		;;; nextLocation not in added
		(evaluate ?nextLocationMinusAdded (SetDifferenceFn (TheSet ?nextLocation) ?added))
    (different ?nextLocationMinusAdded (TheSet))

		;;; add nextLocation to added set
		(evaluate ?nextAdded (SetAdjoinFn ?added ?nextLocation))

		;;; increment round number
		(evaluate ?nextRound (PlusFn ?round 1))

		;;; extract all information that persists from original gamestate
		;;; first 5 cards on trail
		(ist-Information ?gamestate (cardOnTrail ?card1 1))
		(ist-Information ?gamestate (cardOnTrail ?card2 2))
		(ist-Information ?gamestate (cardOnTrail ?card3 3))
		(ist-Information ?gamestate (cardOnTrail ?card4 4))
		(ist-Information ?gamestate (cardOnTrail ?card5 5))
		;;; first 5 locations on trail
		(ist-Information ?gamestate (locationOnTrail ?location1 1))
		(ist-Information ?gamestate (locationOnTrail ?location2 2))
		(ist-Information ?gamestate (locationOnTrail ?location3 3))
		(ist-Information ?gamestate (locationOnTrail ?location4 4))
		(ist-Information ?gamestate (locationOnTrail ?location5 5))
		;;; hunter locations
		(ist-Information ?gamestate (location MinaHarker ?MHLocation))
		(ist-Information ?gamestate (location VanHelsing ?VHLocation))
		(ist-Information ?gamestate (location LordGodalming ?LGLocation))
		(ist-Information ?gamestate (location JohnSeward ?JSLocation))

		;;; despair tokens
		(ist-Information ?gamestate (despairTokens ?numDespairTokens))
		;;; extract damage
		(ist-Information ?gamestate (damage ?damage))
		;;; influence
		(ist-Information ?gamestate (influence ?influence))
		;;; mina’s past search actions
		(ist-Information ?gamestate (usedPsychicBond ?place ?turnsAgo))
		;;; increment turnsAgo
		(evaluate ?newTurnsAgo (PlusFn ?turnsAgo 1))

    ;;; damage
    (ist-Information ?gamestate (damage Dracula ?damage))
    (extraDamage ?damage ?currentLocation ?nextLocation ?newDamage)

	)
	(methodForAction
		(evaluateAdjLocations ?gamestate ?round)
	   (actionSequence
      (TheList
    		;;; build gamestate: with new currentLocation
        (doRecord (ist-Information (GamestateRoundMtFn ?round) (currentLocation ?nextLocation)))
        ;;; first 5 cards on trail all shift down (for our purposes we won’t leave a card behind)
    	  (doRecord (ist-Information (GamestateRoundMtFn ?round) (cardOnTrail ?card1 2)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (cardOnTrail ?card2 3)))
    		(doRecord (ist-Information(GamestateRoundMtFn ?round) (cardOnTrail ?card3 4)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (cardOnTrail ?card4 5)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (cardOnTrail ?card5 6)))
    		;;; first 5 locations on trail all shift down
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (locationOnTrail ?nextLocation 1)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (locationOnTrail ?location1 2)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (locationOnTrail ?location2 3)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (locationOnTrail ?location3 4)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (locationOnTrail ?location4 5)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (locationOnTrail ?location5 6)))
    		;;; hunter locations stay the same
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (location MinaHarker ?MHLocation)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (location VanHelsing ?VHLocation)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (location LordGodalming ?LGLocation)))
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (location JohnSeward ?JSLocation)))

    		;;; despair tokens
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (despairTokens ?numDespairTokens)))
    		;;; influence
    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (influence ?influence)))
    		;;; damage
        (doRecord (ist-Information (GamestateRoundMtFn ?round) (damage ?newDamage)))

    		(doRecord (ist-Information (GamestateRoundMtFn ?round) (usedPsychicBond ?place ?newTurnsAgo)))
    		;;; find stress at child location
    		(doAgentPlan (stressLevel (GamestateRoundMtFn ?round)))
        ;;; pass on information
    		(doRecord (ist-Information (adjLocationsRoundMtFn ?nextRound) (added ?nextAdded)))
    		(doRecord (ist-Information (adjLocationsRoundMtFn ?nextRound) (currentLocation ?currentLocation)))
        )
        )
)
)

;;; evaluateAdjLocations base case

(preconditionForMethod
	(uninferredSentence
  (and

		;;; extract info from roundMt --> all good
		(ist-Information (adjLocationsRoundMtFn ?round) (currentLocation ?currentLocation))
		(ist-Information (adjLocationsRoundMtFn ?round) (added ?added))


		;;; find adjacent location
		(connectedTo ?currentLocation ?nextLocation ?way)
		(elementOf ?way (TheSet road port))

		;;;nextLocation not on trail

		(evaluate ?trailSet (TheClosedRetrievalSetOf ?loc (ist-Information ?gamestate (locationOnTrail ?loc ?space))))


    ;;; failed here until typo (?)
		(uninferredSentence (elementOf ?nextLocation ?trailSet))

		;;; nextLocation not in added
		(evaluate ?nextLocationMinusAdded (SetDifferenceFn (TheSet ?nextLocation) ?added))
     		 (different ?nextLocationMinusAdded (TheSet))

		;;; add nextLocation to added set
		(evaluate ?nextAdded (SetAdjoinFn ?added ?nextLocation))

		;;; increment round number
		(evaluate ?nextRound (PlusFn ?round 1))

	)
)
(methodForAction
	(evaluateAdjLocations ?gamestate ?round)
	(actionSequence
    (TheList
      	;;; we have called stressLevel on all of the neighbors, call part 2
  		(doAgentPlan (pickLocation ?gamestate (TheSet) 0))
    )
	)
)
)


;;; part 2 extract all stressAt s from the various (GamestateRoundMtFn ?round) microtheories
;;; recursive case: still rounds to look at (similar to the clearMt plan)
(preconditionForMethod
	(and
		;;; find the microtheory with corresponding integer and fn
		(evaluate ?mt (GamestateMtFn ?int))

		;;; get the stress level associated with that potential game state
		(ist-Information ?mt (stressAt ?potentialLocation ?stressLevel))

		;;; tuple-ize the location and stress
		(evaluate ?tuple (TheList ?potentialLocation ?stressLevel))

		;;; add this tuple to the stressSet
		(evaluate ?newStressSet (SetAdjoinFn ?stressSet (TheSet ?tuple)))

		;;; increment int
		(evaluate ?newInt (PlusFn ?int 1))
	)
	(methodForAction
		(pickLocation ?gamestate ?stressSet ?int)
		(actionSequence
			(TheList
				(doAgentPlan (pickLocation ?gamestate ?newStressSet ?newInt))
			)
		)
	)
)

;;; base case of pickLocation: no more stressAts to find.
(preconditionForMethod
	(and (uninferredSentence (and
		;;; find the microtheory with corresponding integer and fn
		(evaluate ?mt (GamestateMtFn ?int))

		;;; get the stress level associated with that potential game state
		(ist-Information ?mt (stressAt ?potentialLocation ?stressLevel))
	))
	;;; find min stress level of the stress set
	(evaluate ?minStress (MinimumFn ?stressSet SecondInListFn))
	;;; match that stress to a city
	(elementOf ?lowStressTuple ?stressSet)
	(evaluate ?minStress (SecondInListFn ?lowStressTuple))

  (evaluate ?bestCity (FirstInListFn ?lowStressTuple))
)
(methodForAction
	(pickLocation ?gamestate ?stressSet ?int)
	(actionSequence
		(TheList
			(doRecord (ist-Information ?gamestate (moveTo ?bestCity)))
		)
	)
)
)













;;; location information horn clauses
(<== (conformsToFaceUpCard ?location ?space ?gameState)
  (ist-Information ?gameState (faceUpOnTrail ?trueLocation ?space))
  (evaluate ?trueLocation ?location)
)

(<== (conformsToFaceUpCard ?location ?space ?gameState)
  (uninferredSentence (ist-Information ?gameState (faceUpOnTrail ?trueLocation ?space)))
)

(<== (conformsToSeaCard ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (isa ?trueLocation Sea)
  (isa ?location Sea)
)

(<== (conformsToSeaCard ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (uninferredSentence (isa ?trueLocation Sea))
  (uninferredSentence (isa ?location Sea))
)

(<== (conformsToPositivePsychicBond ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (ist-Information ?gameState (usedPsychicBond ?region ?space))
  (region ?trueLocation ?region)
  (region ?location ?region)
)

(<== (conformsToPositivePsychicBond ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (uninferredSentence
    (and
      (ist-Information ?gameState (usedPsychicBond ?region ?space))
      (region ?trueLocation ?region)
    )
  )
)

(<== (conformsToNegativePsychicBond ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (ist-Information ?gameState (usedPsychicBond ?region ?space))
  (uninferredSentence (region ?trueLocation ?region))
  (uninferredSentence (region ?location ?region))
)

(<== (conformsToNegativePsychicBond ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (uninferredSentence
    (and
      (ist-Information ?gameState (usedPsychicBond ?region ?space))
      (uninferredSentence (region ?trueLocation ?region))
    )
  )
)

(<== (conformsToPreviousHunterLocations ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (ist-Information ?gameState (previouslyLocated ?hunter ?previousLocations))
  (evaluate ?hunterLocation (NthInListFn ?space ?hunter))
  (different ?hunterLocation ?trueLocation)
  (different ?hunterLocation ?location)
)

(<== (conformsToPreviousHunterLocations ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (uninferredSentence
    (and
      (ist-Information ?gameState (previouslyLocated ?hunter ?previousLocations))
      (evaluate ?hunterLocation (NthInListFn ?space ?hunter))
      (different ?hunterLocation ?trueLocation)
    )
  )
)

(<== (validLocation ?location ?space ?gameState)
  (conformsToFaceUpCard ?location ?space ?gameState)
  (conformsToSeaCard ?location ?space ?gameState)
  (conformsToNegativePsychicBond ?location ?space ?gameState)
  (conformsToPositivePsychicBond ?location ?space ?gameState)
  (conformsToPreviousHunterLocations ?location ?space ?gameState)
)

;;; getsearchSpace PLAN

;;; case I: there are no face up locations and space one is neither a psychicBond region or a sea location
(preconditionForMethod
  (and
    (uninferredSentence (ist-Information ?gameState (faceUpOnTrail ?location ?space)))

    ;;; get total number of locations
    (evaluate ?locations
      (TheClosedRetrievalSetOf ?location
        (and
          (isa ?location Location)
        )
      )
    )

    (evaluate ?searchSpace (CardinalityFn ?locations))
  )
  (methodForAction
    (getsearchSpace ?gameState)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpace ?searchSpace)))
      )
    )
  )
)

;;; case II: there are no face up locations and space one is a sea location
(preconditionForMethod
  (and
    (uninferredSentence (ist-Information ?gameState (faceUpOnTrail ?location ?space)))
    (ist-Information ?gameState (locationOnTrail ?location ?space))
    (isa locationOnTrail Sea)

    ;;; get total number of locations
    (evaluate ?locations
      (TheClosedRetrievalSetOf ?location
        (and
          (isa ?location Sea)
        )
      )
    )

    (evaluate ?searchSpace (CardinalityFn ?locations))
  )
  (methodForAction
    (getsearchSpace ?gameState)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpace ?searchSpace)))
      )
    )
  )
)

;;; case III: there are no face up locations and space one is in a psychicBond region
(preconditionForMethod
  (and
    (uninferredSentence (ist-Information ?gameState (faceUpOnTrail ?location ?space)))
    (ist-Information ?gameState (locationOnTrail ?location ?space))
    (ist-Information ?gameState (usedPsychicBond ?region 1))
    (region ?location ?region)

    ;;; get total number of locations
    (evaluate ?locations
      (TheClosedRetrievalSetOf ?someLocation
        (and
          (isa ?someLocation Location)
          (region ?someLocation ?region)
        )
      )
    )

    (evaluate ?searchSpace (CardinalityFn ?locations))
  )
  (methodForAction
    (getsearchSpace ?gameState)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpace ?searchSpace)))
      )
    )
  )
)

;;; case IV: there are face up locations
(preconditionForMethod
  (and
    (evaluate ?locationsOnTrail
      (TheClosedRetrievalSetOf ?duple
        (and
          (ist-Information ?gameState (faceUpOnTrail ?location ?space))
          (evaluate ?duple (TheList ?location ?space))
        )
      )
    )

    (evaluate ?minSpace (MinimumFn ?locationsOnTrail SecondInListFn))

    (elementOf ?minDuple ?locationsOnTrail)
    (evaluate ?minSpace (SecondInListFn ?minDuple))

    (evaluate ?startLocation (FirstInListFn ?minDuple))

    (evaluate ?maxDistance (DifferenceFn ?minSpace 1))
  )
  (methodForAction
    (getSearchSpace ?gameState)
    (actionSequence
      (TheList
        (doRecord (ist-Information (SearchSpaceMtFn 0) (gameState ?gameState)))
        (doRecord (ist-Information (SearchSpaceMtFn 0) (frontier (TheSet (TheList 0 ?startLocation (TheSet ?startLocation))))))
        (doRecord (ist-Information (SearchSpaceMtFn 0) (maxDistance ?maxDistance)))
        (doAgentPlan
          (getLocationsAtDistance 0)
        )
      )
    )
  )
)

;;; getLocationsAtDistance PLAN

;;; base case: frontier only contains tuples at max distance
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (SearchSpaceMtFn ?round) (maxDistance ?maxDistance))
    (ist-Information (SearchSpaceMtFn ?round) (frontier ?frontier))
    (ist-Information (SearchSpaceMtFn ?round) (gameState ?gameState))

    (evaluate ?minDistance (MinimumFn ?frontier FirstInListFn))
    (greaterThanOrEqualTo ?minDistance ?maxDistance)

    ;;; extract locations from frontier
    (evaluate ?locationsInFrontier
      (TheClosedRetrievalSetOf ?location
        (and
          (elementOf ?tuple ?frontier)
          (evaluate ?location (SecondInListFn ?tuple))
        )
      )
    )

    (evaluate ?searchSpace (CardinalityFn ?locationsInFrontier))
  )
  (methodForAction
    (getLocationsAtDistance ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpace ?searchSpace)))
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpaceSet ?locationsInFrontier)))
      )
    )
  )
)

;;; recursive case: there exists a tuple with distance less than maxDistance
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (SearchSpaceMtFn ?round) (maxDistance ?maxDistance))
    (ist-Information (SearchSpaceMtFn ?round) (frontier ?frontier))
    (ist-Information (SearchSpaceMtFn ?round) (gameState ?gameState))

    (evaluate ?minDistance (MinimumFn ?frontier FirstInListFn))
    (lessThan ?minDistance ?maxDistance)

    (elementOf ?minTuple ?frontier)
    (evaluate ?minDistance (FirstInListFn ?minTuple))

    (evaluate ?location (SecondInListFn ?minTuple))
    (evaluate ?path (ThirdInListFn ?minTuple))

    ;;; add next locations to frontier
    (evaluate ?nextLocations
      (TheClosedRetrievalSetOf ?nextTuple
        (and
          ;;; nextLocation is connected to location
          (connectedTo ?location ?nextLocation ?way)
          (elementOf ?way (TheSet road port seaAdjacent))

          (evaluate ?nextDistance (PlusFn ?minDistance 1))

          (evaluate ?nextPath (SetAdjoinFn ?path ?nextLocation))

          (evaluate ?nextSpace (DifferenceFn ?maxDistance ?minDistance))

          ;;; nextLocation is a valid location
          (validLocation ?nextLocation ?nextSpace ?gameState)

          ;;; nextLocation is not in the previous path
          (uninferredSentence (elementOf ?nextLocation ?path))

          (evaluate ?nextTuple (TheList ?nextDistance ?nextLocation ?nextPath))
        )
      )
    )

    (evaluate ?nextFrontier (SetMinusFn (SetOfSetsUnionFn (TheSet ?nextLocations ?frontier)) ?minTuple))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))
  )
  (methodForAction
    (getLocationsAtDistance ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (SearchSpaceMtFn ?nextRound) (frontier ?nextFrontier)))
        (doRecord (ist-Information (SearchSpaceMtFn ?nextRound) (gameState ?gameState)))
        (doRecord (ist-Information (SearchSpaceMtFn ?nextRound) (maxDistance ?maxDistance)))
        (doAgentPlan
          (getLocationsAtDistance ?nextRound)
        )
      )
    )
  )
)














;;; findDistance plan and sub plans

(preconditionForMethod
  (and
  (ist-Information ?microtheory (location Dracula ?currentLocation))
  (ist-Information ?microtheory (location ?hunter ?goalLocation))


  )
  (methodForAction
    (findDistance ?microtheory ?hunter)

    (actionSequence
      (TheList
      (doClearWorkingMemory)
  ;;; bake the initial distance of 0 into the starting frontier
 (doRecord (ist-Information (DijkstrasRoundMtFn 0) (frontier  (TheSet(TheList 0 ?currentLocation) ))))
(doRecord (ist-Information (DijkstrasRoundMtFn 0) (visitedSet (TheSet))))
(doRecord (ist-Information (DijkstrasRoundMtFn 0) (currentLocation ?currentLocation)))
(doRecord (ist-Information (DijkstrasRoundMtFn 0) (goalLocation ?goalLocation)))
(doRecord (ist-Information (DijkstrasRoundMtFn 0) (hunter ?hunter)))
        (doRecord (ist-Information (DijkstrasRoundMtFn 0) (originalMt ?microtheory)))
        (doAgentPlan
          (dijkstra 0)
        )
      )
    )
  )
)




;;; dikstra base case: you’ve finally reached goalLocation!
(preconditionForMethod
  (and
     ;;; extract from microtheory
    (ist-Information (DijkstrasRoundMtFn ?round) (frontier ?frontier))
 (ist-Information (DijkstrasRoundMtFn ?round) (visitedSet ?visitedSet))
 (ist-Information (DijkstrasRoundMtFn ?round) (goalLocation ?goalLocation))
 (ist-Information (DijkstrasRoundMtFn ?round) (hunter ?hunter))
    (ist-Information (DijkstrasRoundMtFn ?round) (originalMt ?originalMt))



;;; preconditions
 ;;; get the tuple with the lowest distance value
    (evaluate ?lowestDistance (MinimumFn ?frontier FirstInListFn))
    (elementOf ?lowestDistanceTuple ?frontier)
    (evaluate ?lowestDistance (FirstInListFn ?lowestDistanceTuple))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))

    ;;; remove tuple from frontier
    (evaluate ?nextFrontier (SetMinusFn ?frontier ?lowestDistanceTuple))

    ;;; extract from tuple
    (evaluate ?currentLocation (SecondInListFn ?lowestDistanceTuple))


    ;;; you’ve reached goal!
     (evaluate ?currentLocation ?goalLocation)

  )
 (methodForAction
    (dijkstra ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?originalMt) (shortestDistance ?hunter ?lowestDistance)))
      )
    )
  )
)



;;; dikstra recursive case: you haven’t reached goalLocation yet!
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (DijkstrasRoundMtFn ?round) (frontier ?frontier))
 (ist-Information (DijkstrasRoundMtFn ?round) (visitedSet ?visitedSet))
 (ist-Information (DijkstrasRoundMtFn ?round) (goalLocation ?goalLocation))
 (ist-Information (DijkstrasRoundMtFn ?round) (hunter ?hunter))
    (ist-Information (DijkstrasRoundMtFn ?round) (originalMt ?originalMt))

    ;;; preconditions

    ;;; get the tuple with the lowest distance value
    (evaluate ?lowestDistance (MinimumFn ?frontier FirstInListFn))
    (elementOf ?lowestDistanceTuple ?frontier)
    (evaluate ?lowestDistance (FirstInListFn ?lowestDistanceTuple))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))

    ;;; extract from tuple
    (evaluate ?currentLocation (SecondInListFn ?lowestDistanceTuple))

    ;;; if the location is the hunter’s location, break out of this plan and go to the base case plan!
     (different ?currentLocation ?goalLocation)

    ;;; if you’ve visited this location before, break out of this plan and go to plan that calls this one
    (evaluate ?currLocationMinusVisitedSet (SetDifferenceFn (TheSet ?currentLocation) ?visitedSet))
   (different ?currLocationMinusVisitedSet (TheSet))

    ;;; remove tuple from frontier
    (evaluate ?nextFrontier (SetMinusFn ?frontier ?lowestDistanceTuple))








   ;;; add this location to the visited set
   (evaluate ?newVisitedSet (SetAdjoinFn ?visitedSet ?currentLocation))


  )
  (methodForAction
    (dijkstra ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (distance ?lowestDistance)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (frontier ?nextFrontier)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (visitedSet ?newVisitedSet)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (goalLocation ?goalLocation)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (added (TheSet))))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (hunter ?hunter)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (currentLocation ?currentLocation)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (originalMt ?originalMt)))

        (doAgentPlan
	;;; add all eligible neighbors to frontier w/ updated distance
          (getNextLocations ?nextRound)
        )
      )
    )
  )
)

;;; dijkstra temporary case: the location w/ the shortest path has been visited before
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (DijkstrasRoundMtFn ?round) (frontier ?frontier))
 (ist-Information (DijkstrasRoundMtFn ?round) (visitedSet ?visitedSet))
 (ist-Information (DijkstrasRoundMtFn ?round) (goalLocation ?goalLocation))
 (ist-Information (DijkstrasRoundMtFn ?round) (hunter ?hunter))
    (ist-Information (DijkstrasRoundMtFn ?round) (originalMt ?originalMt))

    ;;; preconditions

    ;;; get the tuple with the lowest distance value
    (evaluate ?lowestDistance (MinimumFn ?frontier FirstInListFn))
    (elementOf ?lowestDistanceTuple ?frontier)
    (evaluate ?lowestDistance (FirstInListFn ?lowestDistanceTuple))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))

    ;;; extract from tuple
    (evaluate ?currentLocation (SecondInListFn ?lowestDistanceTuple))

    ;;; if the location is the hunter’s location, break out of this plan and go to the base case plan!
     (different ?currentLocation ?goalLocation)

    ;;; if you’ve visited this location before, call the recursive dijkstra plan w/ the same round
    (evaluate ?currLocationMinusVisitedSet (SetDifferenceFn (TheSet ?currentLocation) ?visitedSet))
   (evaluate ?currLocationMinusVisitedSet (TheSet))

    ;;; remove tuple from frontier
    (evaluate ?nextFrontier (SetMinusFn ?frontier ?lowestDistanceTuple))



  )
  (methodForAction
    (dijkstra ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (frontier ?nextFrontier)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (visitedSet ?visitedSet)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (goalLocation ?goalLocation)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (hunter ?hunter)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (originalMt ?originalMt)))

        (doAgentPlan
	;;; call the recursive dijkstra plan w/ the same round number
          (dijkstra ?nextRound)
        )
      )
    )
  )
)


;;; get next locations base case: all connected locations have been added to the frontier
(preconditionForMethod
  (uninferredSentence
    (and
      ;;; extract from microtheory
      (ist-Information (DijkstrasRoundMtFn ?round) (currentLocation ?currentLocation))
      (ist-Information (DijkstrasRoundMtFn ?round) (visitedSet ?visitedSet))
         (ist-Information (DijkstrasRoundMtFn ?round) (frontier ?frontier))
      (ist-Information (DijkstrasRoundMtFn ?round) (added ?added))
      (ist-Information (DijkstrasRoundMtFn ?round) (distance ?distance))

      ;;; preconditions
      (connectedTo ?currentLocation ?nextLocation ?way)

      ;;; nextLocation not in visitedSet
      (evaluate ?nextLocationMinusVisitedSet (SetDifferenceFn (TheSet ?nextLocation) ?visitedSet))
      (different ?nextLocationMinusVisitedSet (TheSet))

      ;;; nextLocation not in added
      (evaluate ?nextLocationMinusAdded (SetDifferenceFn (TheSet ?nextLocation) ?added))
      (different ?nextLocationMinusAdded (TheSet))



    )
  )
  (methodForAction
    (getNextLocations ?round)
    (actionSequence
      (TheList
        (doAgentPlan
          (dijkstra  ?round)
        )
      )
    )
  )
)

;;; get next locations recursive case: some connected locations still need to be added
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (DijkstrasRoundMtFn ?round) (currentLocation ?currentLocation))
    (ist-Information (DijkstrasRoundMtFn ?round) (visitedSet ?visitedSet))
    (ist-Information (DijkstrasRoundMtFn ?round) (goalLocation ?goalLocation))
    (ist-Information (DijkstrasRoundMtFn ?round) (frontier ?frontier))
    (ist-Information (DijkstrasRoundMtFn ?round) (added ?added))
    (ist-Information (DijkstrasRoundMtFn ?round) (hunter ?hunter))
    (ist-Information (DijkstrasRoundMtFn ?round) (distance ?distance))

    (ist-Information (DijkstrasRoundMtFn ?round) (originalMt ?originalMt))

    ;;; preconditions
    (connectedTo ?currentLocation ?nextLocation ?way)

    ;;; nextLocation not in visitedSet
    (evaluate ?nextLocationMinusVisitedSet (SetDifferenceFn (TheSet ?nextLocation) ?visitedSet))
    (different ?nextLocationMinusVisitedSet (TheSet))

    ;;; nextLocation not in added
    (evaluate ?nextLocationMinusAdded (SetDifferenceFn (TheSet ?nextLocation) ?added))
    (different ?nextLocationMinusAdded (TheSet))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))


    ;;; add new path to frontier
    (evaluate ?nextFrontier (SetAdjoinFn ?frontier (TheList (PlusFn ?distance 1) ?nextLocation )))

    ;;; add location to added
    (evaluate ?nextAdded (SetAdjoinFn ?added ?nextLocation))
  )
  (methodForAction
    (getNextLocations ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (distance ?distance)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (frontier ?nextFrontier)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (added ?nextAdded)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (currentLocation ?currentLocation)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (goalLocation ?goalLocation)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (visitedSet ?visitedSet)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (hunter ?hunter)))
        (doRecord (ist-Information (DijkstrasRoundMtFn ?nextRound) (originalMt ?originalMt)))
        (doAgentPlan
          (getNextLocations ?nextRound)
        )
      )
    )
  )
)

;;;; plan to clear mts
;;; base case, microtheory-clearing
(preconditionForMethod
	(uninferredSentence
	(and
		;;; find the microtheory with corresponding integer and fn
		(evaluate ?mt (?microFn ?int))

		;;; some proof that the mt exists
		(ist-Information ?mt (originalMt ?originalMt))

	))
	(methodForAction
		(clearMt ?microFn ?int)
		(actionSequence
			(TheList
				(doClearWorkingMemory)
			)
		)
	)
)

;;; recursive case, microtheory-clearing
(preconditionForMethod
	(and
		;;; find the microtheory with corresponding integer and fn
		(evaluate ?mt (?microFn ?int))

;;; some proof that the mt exists since evaluate won’t defer to base case
		(ist-Information ?mt (originalMt ?originalMt))

		;;; increment int
		(evaluate ?newInt (PlusFn ?int 1))

	)
	(methodForAction
		(clearMt ?microFn ?int)
		(actionSequence
			(TheList
				;;;; clear current mt
				(doForgetKBMt ?mt)

;;;; call this plan again with the newly incremented int
				(clearMt ?microFn ?newInt)
			)
		)
	)
)





;;; part 1 of stress calculations
(preconditionForMethod
	(and
		(ist-Information ?gamestate (location Dracula ?draculaLocation))
	)
	(methodForAction
		(stressLevel ?gamestate)
	(actionSequence
		(TheList
          ;;;call all plans that contribute to stress calculations

          ;;; figure out the search space that dracula can be found within
          (doAgentPlan (getSearchSpace ?gamestate))

          ;;; figure out the distances from all the hunters
          (doAgentPlan (findDistance ?gamestate MinaHarker))
          		(doAgentPlan (clearMt DijkstrasRoundMtFn 0))

          (doAgentPlan (findDistance ?gamestate VanHelsing))
          (doAgentPlan (clearMt DijkstrasRoundMtFn 0))

          	(doAgentPlan (findDistance ?gamestate LordGodalming))
          	(doAgentPlan (clearMt DijkstrasRoundMtFn 0))

          	(doAgentPlan (findDistance ?gamestate JohnSeward))
          	(doAgentPlan (clearMt DijkstrasRoundMtFn 0))

          	;;; don’t need to call the maturingHeuristic horn clause since it can be queried

          	;;; call the plan that decides what Dracula should do given this generated info
          	(doAgentPlan (deciderPlan ?gamestate))


	   )
    )
   )
)




;;; stress calculations part 2-- extracting info and calculating the final number

(preconditionForMethod
  (and
		;;; extract search space number (call it ?searchSpace)
		(ist-Information (ResultsMtFn ?gamestate) (searchSpace ?searchSpace))

		;;; extract Dracula’s current damage
		(ist-Information ?gamestate (damage Dracula ?draculaDamage))

		;;; extract Dracula’s current location
		(ist-Information ?gamestate (location Dracula ?currLocation))

		;;; extract distances from hunters
		(ist-Information (ResultsMtFn ?gamestate) (shortestDistance MinaHarker ?MHDistance))

    (ist-Information (ResultsMtFn ?gamestate) (shortestDistance VanHelsing ?VHDistance))

    (ist-Information (ResultsMtFn ?gamestate) (shortestDistance LordGodalming ?LGDistance))

    (ist-Information (ResultsMtFn ?gamestate) (shortestDistance JohnSeward ?JSDistance))

		;;; extract # despair tokens from gamestate
		(ist-Information ?gamestate (despairTokens ?numDespairTokens))

		;;; extract influence track (an integer) from gamestate
		(ist-Information ?gamestate (influence ?influenceNum))

		;;; encounter cards face up?
    (MaturingHeuristic ?maturingHeuristic)

;;; calculate stress level based on above info --> save as ?stress
;;;normalize searchSpace
(evaluate ?searchSpaceNorm (QuotientFn ?searchSpace 88))

;;; normalize all four hunter distances
(evaluate ?MHDistanceNorm (QuotientFn ?MHDistance 10))
(evaluate ?JSDistanceNorm (QuotientFn ?JSDistance 10))
(evaluate ?VHDistanceNorm (QuotientFn ?VHDistance 10))
(evaluate ?LGDistanceNorm (QuotientFn ?LGDistance 10))

;;; normalize despair tokens
(evaluate ?despairTokensNorm (QuotientFn ?numDespairTokens 3))

;;; normalize influence
(evaluate ?tempInfluence (QuotientFn ?influenceNum 13))

;;; invert Influence
(evaluate ?influenceNumNorm (DifferenceFn 1 ?tempInfluence))

;;; normalize health
(evaluate ?remainingDraculaHeath (DifferenceFn 14 ?draculaDamage))
(evaluate ?remainingHealthNorm (QuotientFn ?remainingDraculaHeath 15))

;;; normalize maturing heuristic (this is causing an error because it's trying to divide 0/21)
(evaluate ?maturingHeuristicNorm (QuotientFn ?maturingHeuristic 21))

;;; find the average of all these values: generates a decimal from 0 - 1
(evaluate ?averageOfCriteria (Average (TheSet (TheList ?maturingHeuristicNorm) (TheList ?remainingHealthNorm) (TheList ?influenceNumNorm) (TheList ?despairTokensNorm) (TheList ?LGDistanceNorm) (TheList ?JSDistanceNorm) (TheList ?VHDistanceNorm) (TheList ?MHDistanceNorm) (TheList ?searchSpaceNorm)) FirstInListFn))

	;;; invert number (so that higher = more stressed)
	(evaluate ?stress (DifferenceFn 1 ?averageOfCriteria))

  )
  (methodForAction
    (deciderPlan ?gamestate)

    (actionSequence
      (TheList

	(doRecord (ist-Information ?gamestate (stressAt ?stress ?currLocation)))

        )
      )
    )
)
