(in-microtheory furyOfDraculaAgentPlansMt)

;;; getLocationsAtDistance PLAN

;;; Initiate frontierSet given start location
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information ?microtheory (startLocation ?startLocation))
    (ist-Information ?microtheory (distance ?distance))
  )
  (methodForAction
    (getLocationsAtDistance ?microtheory)
    (actionSequence
      (TheList
        (doRecord (ist-Information (FrontierLocationsRoundMtFn 0) (distance ?distance)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn 0) (frontier (TheSet (TheList 0 ?startLocation (TheSet ?startLocation))))))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn 0) (originalMt ?microtheory)))
        (doAgentPlan
          (getFrontierLocations 0)
        )
      )
    )
  )
)

;;; getFrontierLocations PLAN

;;; base case: frontier only contains tuples at max distance
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (FrontierLocationsRoundMtFn ?round) (distance ?distance))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (frontier ?frontier))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (originalMt ?originalMt))

    ;;; preconditions
    (evaluate ?lowestDistance (MinimumFn ?frontier FirstInListFn))
    (greaterThanOrEqualTo ?lowestDistance ?distance)

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))
  )
  (methodForAction
    (getFrontierLocations ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (frontier ?frontier)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (originalMt ?originalMt)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (extracted (TheSet))))
        (doAgentPlan
          (getLocationsFromFrontier ?nextRound)
        )
      )
    )
  )
)

;;; recursive case: frontier contains tuples below max distance
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (FrontierLocationsRoundMtFn ?round) (distance ?distance))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (frontier ?frontier))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (originalMt ?originalMt))

    ;;; preconditions
    (evaluate ?lowestDistance (MinimumFn ?frontier FirstInListFn))
    (lessThan ?lowestDistance ?distance)

    (elementOf ?lowestDistanceTuple ?frontier)
    (evaluate ?lowestDistance (FirstInListFn ?lowestDistanceTuple))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))

    ;;; remove tuple from frontier
    (evaluate ?nextFrontier (SetMinusFn ?frontier ?lowestDistanceTuple))

    ;;; extract from tuple
    (evaluate ?currentLocation (SecondInListFn ?lowestDistanceTuple))
    (evaluate ?currentPath (ThirdInListFn ?lowestDistanceTuple))
  )
  (methodForAction
    (getFrontierLocations ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (distance ?distance)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (frontier ?nextFrontier)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (added (TheSet))))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (currentLocation ?currentLocation)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (currentDistance ?lowestDistance)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (currentPath ?currentPath)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (originalMt ?originalMt)))


        (doAgentPlan
          (getNextLocations ?nextRound)
        )
      )
    )
  )
)

;;; getNextLocations PLAN

;;; base case: all connected locations have been added to the frontier
(preconditionForMethod
  (uninferredSentence
    (and
      ;;; extract from microtheory
      (ist-Information (FrontierLocationsRoundMtFn ?round) (currentLocation ?currentLocation))
      (ist-Information (FrontierLocationsRoundMtFn ?round) (currentPath ?currentPath))
      (ist-Information (FrontierLocationsRoundMtFn ?round) (currentDistance ?currentDistance))
      (ist-Information (FrontierLocationsRoundMtFn ?round) (frontier ?frontier))
      (ist-Information (FrontierLocationsRoundMtFn ?round) (added ?added))
      (ist-Information (FrontierLocationsRoundMtFn ?round) (distance ?distance))

      ;;; preconditions
      (connectedTo ?currentLocation ?nextLocation road)

      ;;; nextLocation not in currentPath
      (evaluate ?nextLocationMinusCurrentPath (SetDifferenceFn (TheSet ?nextLocation) ?currentPath))
      (different ?nextLocationMinusCurrentPath (TheSet))

      ;;; nextLocation not in added
      (evaluate ?nextLocationMinusAdded (SetDifferenceFn (TheSet ?nextLocation) ?added))
      (different ?nextLocationMinusAdded (TheSet))
    )
  )
  (methodForAction
    (getNextLocations ?round)
    (actionSequence
      (TheList
        (doAgentPlan
          (getFrontierLocations ?round)
        )
      )
    )
  )
)

;;; recursive case: some connected locations still need to be added
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (FrontierLocationsRoundMtFn ?round) (currentLocation ?currentLocation))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (currentPath ?currentPath))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (currentDistance ?currentDistance))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (frontier ?frontier))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (added ?added))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (distance ?distance))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (originalMt ?originalMt))

    ;;; preconditions
    (connectedTo ?currentLocation ?nextLocation road)

    ;;; nextLocation not in currentPath
    (evaluate ?nextLocationMinusCurrentPath (SetDifferenceFn (TheSet ?nextLocation) ?currentPath))
    (different ?nextLocationMinusCurrentPath (TheSet))

    ;;; nextLocation not in added
    (evaluate ?nextLocationMinusAdded (SetDifferenceFn (TheSet ?nextLocation) ?added))
    (different ?nextLocationMinusAdded (TheSet))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))

    ;;; add new path to frontier
    (evaluate ?nextFrontier (SetAdjoinFn ?frontier (TheList (PlusFn ?currentDistance 1) ?nextLocation (SetAdjoinFn ?currentPath ?nextLocation))))
    ;;; add location to added
    (evaluate ?nextAdded (SetAdjoinFn ?added ?nextLocation))
  )
  (methodForAction
    (getNextLocations ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (distance ?distance)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (frontier ?nextFrontier)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (added ?nextAdded)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (currentLocation ?currentLocation)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (currentDistance ?currentDistance)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (currentPath ?currentPath)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (originalMt ?originalMt)))
        (doAgentPlan
          (getNextLocations ?nextRound)
        )
      )
    )
  )
)

;;; getLocationsFromFrontier PLAN

;;; base case: all locations have been extracted from the frontier
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (FrontierLocationsRoundMtFn ?round) (frontier ?frontier))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (extracted ?extracted))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (originalMt ?originalMt))

    ;;; preconditions
    (uninferredSentence (different ?frontier (TheSet)))
  )
  (methodForAction
    (getLocationsFromFrontier ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMt ?originalMt) (locationsAtDistance ?extracted)))
      )
    )
  )
)

;;; recursive case: some location still needs to be extracted
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (FrontierLocationsRoundMtFn ?round) (frontier ?frontier))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (extracted ?extracted))
    (ist-Information (FrontierLocationsRoundMtFn ?round) (originalMt ?originalMt))

    ;;; preconditions
    (elementOf ?tuple ?frontier)
    (evaluate ?location (SecondInListFn ?tuple))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))

    ;;; remove tuple from frontier
    (evaluate ?nextFrontier (SetMinusFn ?frontier ?tuple))

    ;;; add location to extracted
    (evaluate ?nextExtracted (SetAdjoinFn ?extracted ?location))
  )
  (methodForAction
    (getLocationsFromFrontier ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (frontier ?nextFrontier)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (extracted ?nextExtracted)))
        (doRecord (ist-Information (FrontierLocationsRoundMtFn ?nextRound) (originalMt ?originalMt)))
        (doAgentPlan
          (getLocationsFromFrontier ?nextRound)
        )
      )
    )
  )
)
