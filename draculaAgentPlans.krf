(in-microtheory furyOfDraculaAgentPlansMt)

;;; location information horn clauses
(<== (conformsToFaceUpCard ?location ?space ?gameState)
  (ist-Information ?gameState (faceUpOnTrail ?trueLocation ?space))
  (evaluate ?trueLocation ?location)
)

(<== (conformsToFaceUpCard ?location ?space ?gameState)
  (uninferredSentence (ist-Information ?gameState (faceUpOnTrail ?trueLocation ?space)))
)

(<== (conformsToSeaCard ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (isa ?trueLocation Sea)
  (isa ?location Sea)
)

(<== (conformsToSeaCard ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (uninferredSentence (isa ?trueLocation Sea))
  (uninferredSentence (isa ?location Sea))
)

(<== (conformsToPositivePsychicBond ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (ist-Information ?gameState (usedPsychicBond ?region ?space))
  (region ?trueLocation ?region)
  (region ?location ?region)
)

(<== (conformsToPositivePsychicBond ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (uninferredSentence
    (and
      (ist-Information ?gameState (usedPsychicBond ?region ?space))
      (region ?trueLocation ?region)
    )
  )
)

(<== (conformsToNegativePsychicBond ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (ist-Information ?gameState (usedPsychicBond ?region ?space))
  (uninferredSentence (region ?trueLocation ?region))
  (uninferredSentence (region ?location ?region))
)

(<== (conformsToNegativePsychicBond ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (uninferredSentence
    (and
      (ist-Information ?gameState (usedPsychicBond ?region ?space))
      (uninferredSentence (region ?trueLocation ?region))
    )
  )
)

(<== (conformsToPreviousHunterLocations ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (ist-Information ?gameState (previouslyLocated ?hunter ?previousLocations))
  (evaluate ?hunterLocation (NthInListFn ?space ?hunter))
  (different ?hunterLocation ?trueLocation)
  (different ?hunterLocation ?location)
)

(<== (conformsToPreviousHunterLocations ?location ?space ?gameState)
  (ist-Information ?gameState (locationOnTrail ?trueLocation ?space))
  (uninferredSentence
    (and
      (ist-Information ?gameState (previouslyLocated ?hunter ?previousLocations))
      (evaluate ?hunterLocation (NthInListFn ?space ?hunter))
      (different ?hunterLocation ?trueLocation)
    )
  )
)

(<== (validLocation ?location ?space ?gameState)
  (conformsToFaceUpCard ?location ?space ?gameState)
  (conformsToSeaCard ?location ?space ?gameState)
  (conformsToNegativePsychicBond ?location ?space ?gameState)
  (conformsToPositivePsychicBond ?location ?space ?gameState)
  (conformsToPreviousHunterLocations ?location ?space ?gameState)
)

;;; getSearchSpace PLAN

;;; case I: there are no face up locations and space one is neither a psychicBond region or a sea location
(preconditionForMethod
  (and
    (uninferredSentence (ist-Information ?gameState (faceUpOnTrail ?location ?space)))

    ;;; get total number of locations
    (evaluate ?locations
      (TheClosedRetrievalSetOf ?location
        (and
          (isa ?location Location)
        )
      )
    )

    (evaluate ?searchSpace (CardinalityFn ?locations))
  )
  (methodForAction
    (getSearchSpace ?gameState)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpace ?searchSpace)))
      )
    )
  )
)

;;; case II: there are no face up locations and space one is a sea location
(preconditionForMethod
  (and
    (uninferredSentence (ist-Information ?gameState (faceUpOnTrail ?location ?space)))
    (ist-Information ?gameState (locationOnTrail ?location ?space))
    (isa locationOnTrail Sea)

    ;;; get total number of locations
    (evaluate ?locations
      (TheClosedRetrievalSetOf ?location
        (and
          (isa ?location Sea)
        )
      )
    )

    (evaluate ?searchSpace (CardinalityFn ?locations))
  )
  (methodForAction
    (getSearchSpace ?gameState)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpace ?searchSpace)))
      )
    )
  )
)

;;; case III: there are no face up locations and space one is in a psychicBond region
(preconditionForMethod
  (and
    (uninferredSentence (ist-Information ?gameState (faceUpOnTrail ?location ?space)))
    (ist-Information ?gameState (locationOnTrail ?location ?space))
    (ist-Information ?gameState (usedPsychicBond ?region 1))
    (region ?location ?region)

    ;;; get total number of locations
    (evaluate ?locations
      (TheClosedRetrievalSetOf ?someLocation
        (and
          (isa ?someLocation Location)
          (region ?someLocation ?region)
        )
      )
    )

    (evaluate ?searchSpace (CardinalityFn ?locations))
  )
  (methodForAction
    (getSearchSpace ?gameState)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpace ?searchSpace)))
      )
    )
  )
)

;;; case IV: there are face up locations
(preconditionForMethod
  (and
    (evaluate ?locationsOnTrail
      (TheClosedRetrievalSetOf ?duple
        (and
          (ist-Information ?gameState (faceUpOnTrail ?location ?space))
          (evaluate ?duple (TheList ?location ?space))
        )
      )
    )

    (evaluate ?minSpace (MinimumFn ?locationsOnTrail SecondInListFn))

    (elementOf ?minDuple ?locationsOnTrail)
    (evaluate ?minSpace (SecondInListFn ?minDuple))

    (evaluate ?startLocation (FirstInListFn ?minDuple))

    (evaluate ?maxDistance (DifferenceFn ?minSpace 1))
  )
  (methodForAction
    (getSearchSpace ?gameState)
    (actionSequence
      (TheList
        (doRecord (ist-Information (SearchSpaceMtFn 0) (gameState ?gameState)))
        (doRecord (ist-Information (SearchSpaceMtFn 0) (frontier (TheSet (TheList 0 ?startLocation (TheSet ?startLocation))))))
        (doRecord (ist-Information (SearchSpaceMtFn 0) (maxDistance ?maxDistance)))
        (doAgentPlan
          (getLocationsAtDistance 0)
        )
      )
    )
  )
)

;;; getLocationsAtDistance PLAN

;;; base case: frontier only contains tuples at max distance
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (SearchSpaceMtFn ?round) (maxDistance ?maxDistance))
    (ist-Information (SearchSpaceMtFn ?round) (frontier ?frontier))
    (ist-Information (SearchSpaceMtFn ?round) (gameState ?gameState))

    (evaluate ?minDistance (MinimumFn ?frontier FirstInListFn))
    (greaterThanOrEqualTo ?minDistance ?maxDistance)

    ;;; extract locations from frontier
    (evaluate ?locationsInFrontier
      (TheClosedRetrievalSetOf ?location
        (and
          (elementOf ?tuple ?frontier)
          (evaluate ?location (SecondInListFn ?tuple))
        )
      )
    )

    (evaluate ?searchSpace (CardinalityFn ?locationsInFrontier))
  )
  (methodForAction
    (getLocationsAtDistance ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpace ?searchSpace)))
        (doRecord (ist-Information (ResultsMtFn ?gameState) (searchSpaceSet ?locationsInFrontier)))
      )
    )
  )
)

;;; recursive case: there exists a tuple with distance less than maxDistance
(preconditionForMethod
  (and
    ;;; extract from microtheory
    (ist-Information (SearchSpaceMtFn ?round) (maxDistance ?maxDistance))
    (ist-Information (SearchSpaceMtFn ?round) (frontier ?frontier))
    (ist-Information (SearchSpaceMtFn ?round) (gameState ?gameState))

    (evaluate ?minDistance (MinimumFn ?frontier FirstInListFn))
    (lessThan ?minDistance ?maxDistance)

    (elementOf ?minTuple ?frontier)
    (evaluate ?minDistance (FirstInListFn ?minTuple))

    (evaluate ?location (SecondInListFn ?minTuple))
    (evaluate ?path (ThirdInListFn ?minTuple))

    ;;; add next locations to frontier
    (evaluate ?nextLocations
      (TheClosedRetrievalSetOf ?nextTuple
        (and
          ;;; nextLocation is connected to location
          (connectedTo ?location ?nextLocation ?way)
          (elementOf ?way (TheSet road port seaAdjacent))

          (evaluate ?nextDistance (PlusFn ?minDistance 1))

          (evaluate ?nextPath (SetAdjoinFn ?path ?nextLocation))

          (evaluate ?nextSpace (DifferenceFn ?maxDistance ?minDistance))

          ;;; nextLocation is a valid location
          (validLocation ?nextLocation ?nextSpace ?gameState)

          ;;; nextLocation is not in the previous path
          (uninferredSentence (elementOf ?nextLocation ?path))

          (evaluate ?nextTuple (TheList ?nextDistance ?nextLocation ?nextPath))
        )
      )
    )

    (evaluate ?nextFrontier (SetMinusFn (SetOfSetsUnionFn (TheSet ?nextLocations ?frontier)) ?minTuple))

    ;;; increment round number
    (evaluate ?nextRound (PlusFn ?round 1))
  )
  (methodForAction
    (getLocationsAtDistance ?round)
    (actionSequence
      (TheList
        (doRecord (ist-Information (SearchSpaceMtFn ?nextRound) (frontier ?nextFrontier)))
        (doRecord (ist-Information (SearchSpaceMtFn ?nextRound) (gameState ?gameState)))
        (doRecord (ist-Information (SearchSpaceMtFn ?nextRound) (maxDistance ?maxDistance)))
        (doAgentPlan
          (getLocationsAtDistance ?nextRound)
        )
      )
    )
  )
)
